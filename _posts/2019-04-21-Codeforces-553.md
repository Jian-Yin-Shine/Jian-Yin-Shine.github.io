---
layout:     post   				    # ä½¿ç”¨çš„å¸ƒå±€ï¼ˆä¸éœ€è¦æ”¹ï¼‰
title:      Codeforces 553 				# æ ‡é¢˜ 
subtitle:   Welcome to my blog #å‰¯æ ‡é¢˜
date:       2019-04-21 				# æ—¶é—´
author:     Jian.Yin 						# ä½œè€…
header-img: img/2019-04-21-Codeforces-553/1.jpg 	#è¿™ç¯‡æ–‡ç« æ ‡é¢˜èƒŒæ™¯å›¾ç‰‡
catalog: true 						# æ˜¯å¦å½’æ¡£
tags:
			- Codeforces
			- ç®—æ³•
---





### A. Maxim and Biology

Today in the scientific lyceum of the Kingdom of Kremland, there was a biology lesson. The topic of the lesson was the *genomes*. Let's call the *genome* the string "ACTG".

Maxim was very boring to sit in class, so the teacher came up with a task for him: on a given string ğ‘ s consisting of uppercase letters and length of at least 4, you need to find the minimum number of *operations* that you need to apply, so that the *genome* appears in it as a substring. For one *operation*, you can replace any letter in the string ğ‘ s with the next or previous in the alphabet. For example, for the letter "D" the previous one will be "C", and the next â€” "E". In this problem, we assume that for the letter "A", the previous one will be the letter "Z", and the next one will be "B", and for the letter "Z", the previous one is the letter "Y", and the next one is the letter "A".

Help Maxim solve the problem that the teacher gave him.

A string ğ‘ is a substring of a string ğ‘ if ğ‘a can be obtained from ğ‘ by deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.

```c++
// ç¿»è¯‘ï¼Œå°†ä¸€ä¸ªå­—ç¬¦ä¸²ä¿®æ”¹æˆå«æœ‰ACTGå­ä¸²çš„æœ€å°‘æ­¥æ•°ï¼Œæ¯æ¬¡ä¿®æ”¹åªèƒ½å°†ä¸€ä¸ªå­—æ¯ä¿®æ”¹æˆå‰ä¸€ä¸ªï¼Œæˆ–è€…åä¸€ä¸ªã€‚
#include <stdio.h>
#include <algorithm>
using namespace std;
char str[55];
int calc(int p) {
    int res = 0;
    res += min(abs(str[p] - 'A'), 26-abs(str[p]-'A'));
    res += min(abs(str[p+1] - 'C'), 26-abs(str[p+1]-'C'));
    res += min(abs(str[p+2]-'T'), 26-abs(str[p+2]-'T'));
    res += min(abs(str[p+3]-'G'), 26-abs(str[p+3] - 'G'));
    return res;
}
int main() {
    int n;
    scanf("%d%s",&n, str);
    int ans = 0x3f3f3f3f;
    for(int i = 0; i < n - 4 + 1; i++) {
        ans = min(ans, calc(i));
    }
    printf("%d\n", ans);
    return 0;
}
```



### B. Dima and a Bad XOR

Student Dima from Kremland has a matrix ğ‘a of size ğ‘›Ã—ğ‘š filled with non-negative integers.

He wants to select exactly one integer from each row of the matrix so that the bitwise exclusive OR of the selected integers is strictly greater than zero. Help him!

Formally, he wants to choose an integers sequence ğ‘1,ğ‘2,â€¦,ğ‘ğ‘› (1â‰¤ğ‘ğ‘—â‰¤ğ‘š) so that the inequality ğ‘1,ğ‘1âŠ•ğ‘2,ğ‘2âŠ•â€¦âŠ•ğ‘ğ‘›,ğ‘ğ‘›>0holds, where ğ‘ğ‘–,ğ‘— is the matrix element from the ğ‘–-th row and the ğ‘—-th column.

Here ğ‘¥âŠ•ğ‘¦xâŠ•y denotes the [bitwise XOR operation](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) of integers ğ‘¥ and ğ‘¦.

```python
# ç¿»è¯‘: æœ‰n*m çš„çŸ©é˜µï¼Œä»æ¯ä¸€è¡ŒæŒ‘å‡ºä¸€ä¸ªæ•°ï¼Œä»–ä»¬èƒ½å¦æœ€åå¼‚æˆ–å€¼æ˜¯å¦å¤§äº0ï¼Œå¤§äºé›¶åˆ™ä¾æ¬¡è¾“å‡ºä»–ä»¬çš„ci
# å…ˆæŠŠç¬¬ä¸€åˆ—å¼‚æˆ–èµ·æ¥ï¼Œå¦‚æœç­‰äºé›¶ï¼Œåªè¦åœ¨åŒä¸€è¡Œä¸­æ‰¾åˆ°ä¸€ä¸ªå’Œç¬¬ä¸€ä¸ªä¸åŒçš„å³å¯ã€‚ä»£æ›¿ä»–ã€‚
n, m = [ int(i) for i in input().split() ]
ls = []
for i in range(n):
    ls.append([int(i) for i in input().split() ])

ans = 0
for i in range(n):
    ans^=ls[i][0]
res = []
if ans != 0:
    res = [ 1 for i in range(n) ]
else :
    for i in range(n):
        for j in range(m):
            if ls[i][0]!=ls[i][j]:
                # python åˆå¹¶åˆ—è¡¨ç”¨ +
                res+=[1 for k in range(i)]
                res.append(j+1)
                res+=[1 for k in range(i+1, n)]
                break
        if len(res) > 0:
            break

if len(res) == 0:
    print('NIE')
else :
    print('TAK')
    for i in res:
        print(i, end=' ')
    print("")
```



### D. Stas and the Queue at the Buffet

During a break in the buffet of the scientific lyceum of the Kingdom of Kremland, there was formed a queue of ğ‘› high school students numbered from 1 to ğ‘›. Initially, each student ğ‘– is on position ğ‘–. Each student ğ‘– is characterized by two numbers â€” ğ‘ğ‘– and ğ‘ğ‘–. *Dissatisfaction* of the person ğ‘– equals the product of ğ‘ğ‘– by the number of people standing to the left of his position, add the product ğ‘ğ‘– by the number of people standing to the right of his position. Formally, the *dissatisfaction* of the student ğ‘–, which is on the position ğ‘—, equals ğ‘ğ‘–â‹…(ğ‘—âˆ’1)+ğ‘ğ‘–â‹…(ğ‘›âˆ’ğ‘—).

The director entrusted Stas with the task: rearrange the people in the queue so that **minimize the total** *dissatisfaction*.

Although Stas is able to solve such problems, this was not given to him. He turned for help to you.

```python
# ç¿»è¯‘ï¼šæœ‰nä¸ªäººï¼ˆ1ï½nï¼‰ï¼Œå­¦ç”Ÿ i æœ‰ai, biï¼Œå¦‚æœä»–åœ¨ä½ç½® j ï¼Œä»–çš„ä¸æ»¡æ„å€¼ä¸º ai*(j-1) + bi*(n - j)
# æ±‚æ€ä¹ˆæ ·æ’é˜Ÿåˆ—ï¼Œæ»¡æ„å€¼æœ€å°ã€‚
# åˆšå¼€å§‹ä¸€åªè´ªå¿ƒï¼Œè¯´å¦‚æœsum(a) > sum(b)ï¼Œ å°±æŒ‰ç…§a æ’åºç­‰ç­‰ã€‚
# a*(j-1) + b(n-j) = (a-b)*j + b*n - aï¼Œæ ¹æ®å…¬å¼ï¼Œæ˜¯æŒ‰ç…§(a-b)æ’åºã€‚
n = int(input())
ls = []
for i in range(n):
     ls.append([int(i) for i in input().split()])
ls.sort(key = lambda x: x[0]-x[1], reverse=True)
ans = 0
for i in range(n):
    ans += (ls[i][0]*i + ls[i][1]*(n-i-1))
print(ans)
```

